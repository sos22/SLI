/* Simple thing to merge the type tables generated by the dynamic
   analysis. */
#include <err.h>
#include <stdio.h>
#include <map>
#include <set>
#include <vector>

#include "sli.h"
#include "raw_types.hpp"

struct aliasing_entry {
	std::set<rip_t> loads;
	std::set<rip_t> stores;
};

static std::map<rip_t, aliasing_entry> mass_table;

static void
addDbToGlobalTable(const input_database &db, const char *fname)
{
	unsigned long cntr;

	cntr = 0;
	for (auto it = db.content.begin(); it != db.content.end(); it++) {
		aliasing_entry &ae(mass_table[it->rip]);
		cntr += it->loads.size();
		cntr += it->stores.size();
		for (auto it2 = it->loads.begin(); it2 != it->loads.end(); it2++)
			ae.loads.insert(*it2);
		for (auto it2 = it->stores.begin(); it2 != it->stores.end(); it2++)
			ae.stores.insert(*it2);
	}
	printf("Input %s had %ld edges\n", fname, cntr);
}

static void
flushGlobalTable(sane_write_file &outf)
{
	unsigned long cntr;
	cntr = 0;
	for (auto it = mass_table.begin(); it != mass_table.end(); it++) {
		input_record ir;
		ir.rip = it->first;
		ir.loads.insert(ir.loads.end(),
				it->second.loads.begin(),
				it->second.loads.end());
		ir.stores.insert(ir.stores.end(),
				 it->second.stores.begin(),
				 it->second.stores.end());
		ir.write(outf);
		cntr += it->second.loads.size() + it->second.stores.size();
	}
	printf("Output has %ld edges\n", cntr);
}

int
main(int argc, char *argv[])
{
	init_sli();

	const char *binary = argv[1];
	const char *output = argv[2];

	MachineState *ms = MachineState::readELFExec(binary);

	for (int i = 3; i < argc; i++) {
		struct input_database db;
		FILE *f = fopen(argv[i], "r");
		if (!f)
			err(1, "cannot open %s", argv[i]);
		db.read(f, ms->addressSpace);
		addDbToGlobalTable(db, argv[i]);
	}

	FILE *outf = fopen(output, "w");
	if (!outf)
		err(1, "opening %s", output);
	sane_write_file outfile(outf);
	flushGlobalTable(outfile);
	if (fclose(outf) == EOF)
		err(1, "closing output file");
	return 0;
}
