/* This converts the types table from the format generated by the
   dynamic analysis into the one which is used by the oracle.  That
   means two things:

   1) Remove anything which refers to stuff outside of the main
      binary.
   2) Sort and index the table.
*/
#include "sli.h"

#define PRIVATE_RIP_FLAG 0x80000000
#define SECOND_LEVEL_IDX_INTERVAL 4096

struct rip_t {
	int is_private;
	std::vector<unsigned long> stack;
	bool read(FILE *f, AddressSpace *as);
	bool operator<(const rip_t &o) const {
		if (stack < o.stack)
			return true;
		if (stack > o.stack)
			return false;
		return is_private < o.is_private;
	}
	bool operator>(const rip_t &o) const {
		return o < *this;
	}
};

bool
rip_t::read(FILE *f, AddressSpace *as)
{
	unsigned nr_items;
	if (fread(&nr_items, sizeof(nr_items), 1, f) != 1)
		errx(1, "input truncated");
	assert(nr_items < 1000000);
	unsigned long content[nr_items];
	if (fread(content, sizeof(content[0]), nr_items, f) != nr_items)
		errx(1, "input truncated");
	is_private = 0;
	if (content[nr_items - 1] & (1ul << 63)) {
		is_private = 1;
		content[nr_items - 1] &= ~(1ul << 63);
	}
	for (unsigned x = 0; x < nr_items; x++)
		if (as->isReadable(content[x], 1))
			stack.push_back(content[x]);
	if (!as->isReadable(content[nr_items - 1], 1))
		return false;
	return true;
}

struct input_record {
	rip_t rip;
	std::vector<rip_t> loads;
	std::vector<rip_t> stores;
	bool read(FILE *f, AddressSpace *as);
	bool operator<(const input_record &o) const {
		if (rip < o.rip)
			return true;
		if (rip > o.rip)
			return false;
		if (loads < o.loads)
			return true;
		if (loads > o.loads)
			return false;
		if (stores < o.stores)
			return true;
		return false;
	}
};

bool
input_record::read(FILE *f, AddressSpace *as)
{
	int nr_loads, nr_stores;
	bool res;
	if (fread(&nr_loads, sizeof(nr_loads), 1, f) != 1)
		return false;
	fread(&nr_stores, sizeof(nr_stores), 1, f);
	res = rip.read(f, as);
	for (int i = 0; i < nr_loads; i++) {
		rip_t r;
		if (r.read(f, as))
			loads.push_back(r);
	}
	for (int i = 0; i < nr_stores; i++) {
		rip_t r;
		if (r.read(f, as))
			stores.push_back(r);
	}
	if (loads.empty() && stores.empty())
		return false;
	return res;
}

struct input_database {
	std::vector<input_record> content;
	void read(FILE *f, AddressSpace *as);
};

void
input_database::read(FILE *f, AddressSpace *as)
{
	while (1) {
		struct input_record ir;
		if (ir.read(f, as)) {
			content.push_back(ir);
		} else if (feof(f)) {
			break;
		} else if (ferror(f)) {
			err(1, "reading input");
		}
	}
}

static void
write_output_rip(const rip_t &r, FILE *output)
{
	unsigned nr_entries = r.stack.size();
	if (r.is_private)
		nr_entries |= PRIVATE_RIP_FLAG;
	fwrite(&nr_entries, sizeof(nr_entries), 1, output);
	for (auto it = r.stack.begin(); it != r.stack.end(); it++)
		fwrite(&*it, sizeof(*it), 1, output);
}

static void
transform_record(const input_record &ir, FILE *output)
{
	int nr_loads, nr_stores;
	nr_loads = ir.loads.size();
	nr_stores = ir.stores.size();
	fwrite(&nr_loads, sizeof(nr_loads), 1, output);
	fwrite(&nr_stores, sizeof(nr_loads), 1, output);
	for (auto it = ir.loads.begin(); it != ir.loads.end(); it++)
		write_output_rip(*it, output);
	for (auto it = ir.stores.begin(); it != ir.stores.end(); it++)
		write_output_rip(*it, output);
}

static void
copy_rip(FILE *input, FILE *output)
{
	unsigned nr_entries;
	fread(&nr_entries, sizeof(nr_entries), 1, input);
	fwrite(&nr_entries, sizeof(nr_entries), 1, output);
	nr_entries &= ~PRIVATE_RIP_FLAG;
	unsigned long stack[nr_entries];
	fread(stack, sizeof(unsigned long), nr_entries, input);
	fwrite(stack, sizeof(unsigned long), nr_entries, output);
}

static void
copy_record(FILE *input, FILE *output)
{
	int nr_loads, nr_stores;
	fread(&nr_loads, sizeof(nr_loads), 1, input);
	fwrite(&nr_loads, sizeof(nr_loads), 1, output);
	fread(&nr_stores, sizeof(nr_stores), 1, input);
	fwrite(&nr_stores, sizeof(nr_stores), 1, output);
	for (int i = 0; i < nr_loads; i++)
		copy_rip(input, output);
	for (int i = 0; i < nr_stores; i++)
		copy_rip(input, output);
}

static void
add_index_entry(const rip_t &rip, unsigned long offset, FILE *f)
{
	write_output_rip(rip, f);
	fwrite(&offset, sizeof(offset), 1, f);
}

static void
rewrite_index_entry(FILE *input, FILE *output, unsigned long delta)
{
	copy_rip(input, output);
	unsigned long offset;
	fread(&offset, sizeof(offset), 1, input);
	offset += delta;
	fwrite(&offset, sizeof(offset), 1, output);
}

static void
write_index(FILE *output,
	    const std::vector<std::pair<rip_t, unsigned long> > idx,
	    std::vector<std::pair<rip_t, unsigned long> > &idx_next_level,
	    std::vector<std::pair<unsigned long, unsigned long> > &regions)
{
	unsigned long idx_start = ftell(output);
	unsigned long last_idx2 = idx_start;
	
	for (auto it = idx.begin(); it != idx.end(); it++) {
		if (ftell(output) >= (long)last_idx2 + SECOND_LEVEL_IDX_INTERVAL)
			idx_next_level.push_back(std::pair<rip_t, unsigned long>(it->first, ftell(output) - idx_start));
		add_index_entry(it->first, it->second, output);
	}
	regions.push_back(std::pair<unsigned long, unsigned long>(idx_start, ftell(output)));
}

int
main(int argc, char *argv[])
{
	init_sli();

	if (argc != 4)
		errx(1, "need three arguments, the binary, the raw type file and the output file");

	const char *binary = argv[1];
	const char *input_fname = argv[2];
	const char *output_fname = argv[3];

	VexPtr<MachineState> ms(MachineState::readELFExec(binary));

	FILE *inp = fopen(input_fname, "r");
	if (!inp)
		err(1, "opening %s", input_fname);
	FILE *tmp = tmpfile();
	if (!tmp)
		err(1, "opening temporary file");

	input_database input;
	input.read(inp, ms->addressSpace);
	fclose(inp);
	std::sort(input.content.begin(), input.content.end());

	std::vector<std::pair<rip_t, unsigned long> > idx;
	for (auto it = input.content.begin(); it != input.content.end(); it++) {
		idx.push_back(std::pair<rip_t, unsigned long>(it->rip, ftell(tmp)));
		transform_record(*it, tmp);
	}

	std::vector<std::pair<unsigned long, unsigned long> > indexes;

	std::vector<std::pair<rip_t, unsigned long> > idx2;
	write_index(tmp, idx, idx2, indexes);
	while (idx2.size() > 10) {
		idx = idx2;
		write_index(tmp, idx, idx2, indexes);
	}

	FILE *output = fopen(output_fname, "w");
	if (!output)
		err(1, "opening output");

	/* Now write the final thing by reversing the order of the
	 * indexes, so that the root index is at the front of the
	 * file. */

	/* Start with the index shape. */
	unsigned long o = 4 + 16 * indexes.size();
	{
		unsigned nr_indexes = indexes.size();
		fwrite(&nr_indexes, sizeof(nr_indexes), 1, output);
		for (auto it = indexes.rbegin(); it != indexes.rend(); it++) {
			unsigned long old_begin = it->first;
			unsigned long old_end = it->second;
			unsigned long new_begin = o;
			unsigned long new_end = new_begin + old_end - old_begin;
			o = new_end;
			fwrite(&new_begin, sizeof(new_begin), 1, output);
			fwrite(&new_end, sizeof(new_end), 1, output);
		}
	}
	o = 4 + 16 * indexes.size();
	for (auto it = indexes.rbegin(); it != indexes.rend(); it++) {
		unsigned long begin = it->first;
		unsigned long end = it->second;
		o += end - begin;
		printf("Index %lx -> %lx, o %lx\n", begin, end, o);
		fseek(tmp, begin, SEEK_SET);
		while (ftell(tmp) < (long)end)
			rewrite_index_entry(tmp, output, o);
	}
	/* Now write out the actual content of the file */
	fseek(tmp, 0, SEEK_SET);
	while (ftell(tmp) < (long)indexes[0].first)
		copy_record(tmp, output);

	if (fclose(output) == EOF)
		err(1, "closing output file");

	return 0;  
}
